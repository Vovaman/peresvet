.. include:: <isonum.txt>

.. |br| raw:: html

   <br/>

methods (методы)
~~~~~~~~~~~~~~~~
Методы используются для вычислений значений тегов.
Значение тега может приходить из внешнего источника, а может быть вычислено,
для чего необходимо:

1. Написать метод для вычисления значений тега.
2. Привязать этот метод к тегу, указав, какие события будут инициировать
   расчёт.

Создание вычислительного метода тега
""""""""""""""""""""""""""""""""""""
Рассмотрим создание вычислительного метода тега на следующем примере:
допустим, у нас есть объект "комната" и в этой комнате - два потребителя
электроэнергии: освещение и телевизор. С каждого потребителя мы можем получать
количество потреблённой энергии в киловатт-часах.

Комната же имеет тег "Суммарная потреблённая энергия", значение которого
должно вычисляться как сумма потреблённой энергии освещением и телевизором,
причём значение этого тега должно пересчитываться каждый раз, когда мы
получаем новое значение потреблённой энергии от потребителей электроэнергии
в комнате.

**Подготовка иерархии объектов и тегов**
Создание объектов и тегов не будем здесь детально описывать - см.
соответствующие разделы документации.

Покажем иерархию созданных объектов и тегов:

.. figure:: microservices/methods/pics/methods_01.png
    :align: center

    Объекты

**Создание расчётного метода**
Опишем процесс создания расчётного метода для тега
"Суммарная потреблённая энергия" объекта "Комната".

.. note::
   Для управления распределёнными вычислениями используются библиотеки
   `patio <https://pypi.org/project/patio/>`_ и
   `patio_rabbitmq <https://pypi.org/project/patio-rabbitmq/>`_.

Создадим скрипт на языке **python**, предварительно установив пакеты
"patio" и "patio_rabbitmq":

.. code:: python

   import asyncio
   from patio import Registry, AsyncExecutor
   from patio_rabbitmq import RabbitMQBroker

   rpc = Registry(project="MPKPeresvet_calcs", auto_naming=False)

   @rpc("sum")
   async def sum(a: float, b: float) -> float:
      return a+b

   async def main():
      async with AsyncExecutor(rpc, max_workers=16) as executor:
         async with RabbitMQBroker(
               # измените параметры подключения к RabbitMQ
               executor, amqp_url="amqp://uid:pwd@server/",
         ) as broker:
               await broker.join()

   if __name__ == "__main__":
      asyncio.run(main())

.. attention::

   Отметим, что расчётный метод регистрируется в системе под именем "sum":
   ``@rpc("sum")``.

Созданный нами расчётный метод имеет два входных параметра: ``a`` и ``b``.

**Создание узла для расчётного метода**
Теперь нам необходимо создать узел, описывающий расчётный метод для тега
"Суммарная потреблённая энергия".

При создании узла мы должны указать:

1. зарегистрированное имя метода ("sum");
2. на вход метод принимает два параметра;
3. в качестве значений параметров должны передаваться значения тегов
   "Потреблённая энергия" объектов "Освещение" и "Телевизор";
4. метод должен инициироваться изменением двух вышеуказанных тегов.

Соответственно, получаем такое тело запроса, который мы должны выполнить
для создания узла метода:

.. attention::

   Для удобства предположим, что:

   1. id тега "Суммарная потреблённая энергия" = 1
   2. id "Освещение --> Потреблённая энергия" = 2
   3. id "Телевизор --> Потреблённая энергия" = 3

.. code:: python

   # request: POST http://<srv>/v1/methods

   # body:

   {
      # id вычисляемого тега ("Суммарная потреблённая энергия")
      "parentId": "1",
      "attributes": {
         # зарегистрированное имя метода
         "cn": "Сумма",
         "prsMethodAddress": "sum"
      },
      # id тегов "Потреблённая энергия" объектов "Освещение" и "Телевизор"
      "initiatedBy": ["2", "3"],
      "parameters": [
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"2\"}"
            }
         },
         {
            "attributes": {
               "prsJsonConfigString": "{\"tagId\": \"3\"}"
            }
         }
      ]
   }
