Руководство разработчика
========================
Используемые термины
--------------------
**Модель технического объекта** - совокупность статической и
динамической моделей объекта.

**Статическая модель объекта** - иерархия сущностей. Также в иерархию
включаются сущности, описывающие информационную систему.
В простейшем случае статическая модель может представлять собой просто
линейный список тегов (параметров объектов).

**Динамическая модель** - совокупность методов, реализуемых на каких-либо
языках программирования. В виде методов реализуются бизнес-процессы,
протекающие на моделируемом объекте, а также выполняются расчёты значений
рассчитываемых тегов. Выполнение методов инициируется при возникновении
событий в модели.

**Сущность** - основные типы сущностей статической модели технического
объекта: тег, объект, тревога, метод, расписание, константы.
Дополнительные сущности, описывающие информационную систему: хранилище данных,
источник данных.
Также есть возможность создавать дополнительные сущности, самостоятельно
реализуя логику работы с ними.

**Тег** - параметр объекта. Например: температура, давление, сила тока и т.д.
Значения тегов хранятся в том или ином хранилище данных. Каждое значение тега
обязательно имеет метку времени. Кроме того, может иметь показатель качества
значения.
.. warning:: Если хранилище данных - Victoriametrics, показатель качества
не поддерживается.

Тег в иерархии представляется узлом, дочерним по отношению к какому-либо
объекту.

Поддерживаемые типы значений тегов: целый, вещественный, строковый, json.

**Объект** - основная сущность при моделировании технических объектов.
Объектом может быть: предприятие, цех, участок, технологическая линия, агрегат,
датчик и т.д. Каждый объект может содержать любое количество объектов-потомков.
Также объект может содержать любое количество тегов.

**Расписание** - заданная последовательность, определяющая моменты времени,
в которые будут выполняться те или иные задачи. Задачами могут быть: запуск
расчёта вычисляемых тегов, запуск на исполнение каких-либо методов (к примеру,
генерация отчётов и рассылка их по почте).

**Событие** - в платформе поддерживаются три основных типа событий: изменение
тега, возникновение тревоги, событие расписания. К этим событиям можно
привязывать выполнение различных методов, тем самым "оживляя" модель
технического объекта. События являются инициаторами действий.

**Тревога** - это состояние тега, которое может возникнуть при изменении тега и
при выполнении некоторых заданных условий. Есть четыре вида стандартных тревог:
LoLo, Lo, Hi, HiHi.

| Пример: аквариум, в котором живут рыбки, для которых комфортной температурой
| воды является диапазон от 20 до 25࠾C. Температура же ниже 15࠾C или выше
| 30࠾C является опасной. В таком случае, к тегу, который хранит значения
| температуры воды в аквариуме, привязываем четыре тревоги: LoLo = 15࠾C;
| Lo = 20࠾C; Hi = 25࠾C; HiHi = 30࠾C.
| Таким образом, возникновение тревог Lo или Hi является сигналом, что вода в
| аквариуме вышла из комфортных пределов, то есть стоит обратить внимание
| на регулировку температуры. Возникновение же тревог LoLo или HiHi сигнализирует
| о том, что необходимо принимать срочные меры.

В МПК-Пересвет, в отличие от типовых тревог LoLo-Lo-Hi-HiHi, есть возможность
создать любое их количество. Более того, возможно создавать сложные тревоги,
возникновение которых учитывает значение других тегов. Это достигается тем,
что условием возникновения тревоги может быть указано не только какое-то
значение тега, а результат расчёта метода, который может реализовывать любую
сложную логику.

**Метод** - программный код, который может управляться
`Celery <https://docs.celeryq.dev>`_.
Методы вызываются на исполнение возникающими событиями и используются для:
расчёта значений вычисляемых тегов, определения факта возникновения/пропадания
тревоги, вызова внешних процессов.

**Хранилище данных** - база данных, в которой хранятся исторические данные
(значения тегов). Платформа может поддерживать одновременно несколько хранилищ
данных разных типов. Рекомендуемое хранилище данных для систем промышленной
автоматизации - PostgreSQL. Также есть драйвер для Victoriametrics. Возможно
написание драйверов для любых других типов хранилищ данных.

Архитектура платформы
---------------------
Платформа представляет собой совокупность сервисов.
В основном, каждый сервис работает с какой-либо сущностью, представленной
в иерархической модели объекта.

В общем случае для каждой сущности создаётся 4 микросервиса:

#. **<сущность>_api_crud**

   Сервис обеспечивает API для команд create-read-update-delete для
   работы с экземплярами сущности в иерархической модели.

   Каждый сервис типа ``api_crud`` выполняет две задачи:

      #. проверяет корректность входных данных запроса;

         В случае реализации на языке Python эту задачу удобно выполнять с
         помощью модуля ``Pydantic``.

      #. посылает соответствующее сообщение сервису ``<сущность>_model_crud``;

         В случае команд ``create`` и ``read`` сообщение выполняется по
         RPC-шаблону (команда ``create`` возвращает id вновь созданного
         экземпляра сущности, команда ``read`` возвращает результат поиска).

         В случае же команд ``update`` и ``delete`` ответа от
         ``<сущность>_model_crud`` не ожидается.

#. **<сущность>_model_crud**

   Сервис обеспечивает функциональность для работы с экземплярами сущности
   в иерархической модели при выполнении команд CRUD.

#. **<сущность>_app**

   Сервис реализует логику работы сущности, то есть ту функциональность, ради
   которой и создаются экземпляры сущности.

   К примеру, для сущности **тревоги** этот сервис реализует логику
   возникновения/квитирования/пропадания тревог.

#. **<сущность>_app_api**

   Сервис реализует команды для работы с сущностью, не входящие в группу
   CRUD.

   Для сущности **тревоги** это команды: получения списка активных тревог,
   квитирования тревоги и т.д.

Сервисы общаются между собой через брокер сообщений
`RabbitMQ <https://www.rabbitmq.com/>`_.

Каждый сервис создаёт exchange (здесь и далее - обменник) со своим именем и
с типом, указанным в конфигурации сервиса в переменной ``pub_exchange_type``.

В документации на каждый сервис указано, какие сообщения он публикует, а также
на какие сообщения и от каких сервисов подписывается.

API
---
Общие классы
~~~~~~~~~~~~
В этом разделе описаны общие классы, от которых наследуются все сервисы,
а также классы, используемые всеми сервисами.

.. include:: common_classes.rst

Микросервисы
~~~~~~~~~~~~
.. include:: microservices.rst
