.. include:: <isonum.txt>

Архитектура платформы
=====================
Общее описание
--------------
Архитектура платформы обуславливается, в значительной степени, создаваемой
ей моделью технического объекта.

Модель технического объекта состоит из двух частей: статической и динамической.
Статическая модель описывает сущности и экземпляры этих сущностей,
а динамическая - процессы, протекающие между экземплярами сущностей.

Статическая модель
------------------
Статическая модель технических объектов, особенно в промышленности, хорошо
описывается иерархической структурой. К примеру:

``Предприятие`` |rarr| ``Цех`` |rarr| ``Участок`` |rarr|
``Технологическая линия`` |rarr| ``Агрегат``.

Поэтому в архитектуре появляется LDAP-сервер, с помощью которого
строится иерархия.

.. figure:: pics/architecture_01.png
    :align: center

    LDAP-сервер

Каждый узел в иерархии LDAP-сервера имеет свой определённый класс.
На рисунке ниже представлена иерархия узлов.

В скобках указан класс узла.

.. figure:: pics/architecture_02.png
    :align: center

    Иерархия

На рисунке выше показан пример иерархии. Белыми квадратами показаны экземпляры
сущности ``object`` (класс в иерархии - ``prsObject``), голубыми - теги,
красными - тревоги (alerts), зелёными - методы.

.. note::
   Имена всех классов в иерархии строятся по принципу: ``prs<Имя сущности>``.
   Префикс ``prs`` облегчает фильтрацию классов, добавленных в схему сервера
   платформой.
   Имена атрибутов также имеют префикс ``prs``.

1. Главный узел - ``Участок металлообработки``. Класс - ``prsObject``.
2. ``Участок`` содержит два тега:

   * ``Суммарная мощность`` (всех станков на участке);
   * ``Температура помещения``.
3. Тег ``Участок металлообработки.Суммарная мощность`` имеет метод для
   вычисления суммы мощностей всех станков на участке.
4. Тег ``Участок металлообработки.Температура помещения`` имеет тревогу
   ``Превышение температуры``, которая срабатывает при превышении некоторого
   установленного значения.
5. У объекта ``Участок`` - два дочерних объекта: ``Станок 1`` и ``Станок 2``.
6. Каждый станок имеет два тега:

   * ``Потребляемая мощность``;
   * ``Ток фазы``.
7. Tег ``Ток фазы`` имеет тревогу ``Превышение тока``, которая, в свою очередь,
   имеет метод ``Оповещение``.

Таким образом, в примере иерархии содержатся экземпляры четырёх сущностей:
``objects``, ``tags``, ``alerts``, ``methods``.

.. note::
   В иерархии LDAP-сервера содержатся сущности, относящиеся не столько к модели
   самого технического объекта, сколько к модели информационной системы. Это
   такие сущности, как: хранилища данных (dataStorages), коннекторы (connectors),
   расписания (schedules).

Сервисы
-------
Каждая сущность, присутствующая в иерархии, управляется своим сервисом.

.. figure:: pics/architecture_03.png
    :align: center

    Сервисы

В действительности, каждый сервис - это, в общем случае, набор из четырёх
независимых микросервисов:

.. figure:: pics/architecture_04.png
    :align: center

    Микросервисы

<сущность>_api_crud
~~~~~~~~~~~~~~~~~~~
Микросервис, принимающий от пользователя или, в общем, от любых внешних
клиентов, запросы на создание, чтение, обновление, удаление экземпляров
сущности (команды CRUD).

Главная задача этого микросервиса - принять запрос от клиента и проверить
корректность параметров запроса (в случае, если миросервис реализован
на языке Python, то удобно для этих целей пользоваться модулем ``pydantic``).

Вторая задача - отправить соответствующий запрос микросервису
``<сущность>_model_crud``:

.. figure:: pics/architecture_05.png
    :align: center

    <сущность>_api_crud

Выделение описанной функциональности в отдельный микросервис облегчает
управление версиями API, позволяя, в том числе, работать одновременно
нескольким версиям. Вопрос только в запуске/остановке соответствующего
микросервиса.

<сущность>_model_crud
~~~~~~~~~~~~~~~~~~~~~
Микросервис, работающий с узлами сущности в иерархии. Именно этот сервис
реализует непосредственную работу с иерархической моделью, взаимодействуя
с LDAP-сервером.

.. figure:: pics/architecture_06.png
    :align: center

    <сущность>_model_crud

<сущность>_app
~~~~~~~~~~~~~~
Иерархическая модель - не вещь в себе. Узлы в ней определяют, как функционирует
модель технического объекта.
То есть микросервис ``<сущность>_app`` определяет ту функциональность, ради
которой экземпляры сущности и создаются.
Например, для тегов это, в первую очередь, функции записи/чтения данных.
Для тревог - функциональность по инициации/квитированию/прападанию тревог.

Таким образом, сервис ``<сущность>_app`` читает из иерархии описания
узлов соответствующего типа и работает согласно этим описаниям.
Например, к тегу ``Температура помещения`` привязана тревога
``Превышение температуры``. Так вот именно сервис ``alerts_app`` будет
отслеживать значение температуры и генерировать, при необходимости, тревогу.

.. figure:: pics/architecture_07.png
    :align: center

    <сущность>_app

<сущность>_app_api
~~~~~~~~~~~~~~~~~~
Микросервис предоставляет клиентам доступ к функциональности сервиса
``<сущность>_app``. В случае тегов - это команды ``data/set``, ``data/get``.

В случае тревог - команды квитирования, получения списка активных тревог и
т.д.

.. figure:: pics/architecture_08.png
    :align: center

    <сущность>_app_api

Базовые сущности, входящие в ядро МПК Пересвет
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Объекты
"""""""
.. note::
   Сущность ``objects``, класс в иерархии ``prsObject``.

Базовый узел в иерархии. Каждый узел сущности ``objects`` может иметь
любое количество дочерних узлов этой же сущности. Таким образом обеспечивается
возможность создания иерархии объектов любой сложности.

Теги
""""
.. note::
   Сущность ``tags``, класс в иерархии ``prsTag``

Тег - это параметр объекта. Например: температура, давление, расход, и т.д.

Теги бывают обычные, в которые данные поступают из внешних источников
(датчики, SCADA, ручной ввод и т.д.), а также рассчитываемые.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:**

* тег ``Потребляемая мощность`` у объекта ``Котёл`` в системе "умного дома" -
  обычный тег, данные в который поступают от "умной" розетки по протоколу
  "ZigBee";
* тег ``Общий расход газа на собственные нужды`` объекта ``Промысел`` -
  вычисляемый и является суммой затрат газа на котельные промысла,
  а также потерь на факел;

Но ничто не мешает тегу быть одновременно и обычным, и рассчитываемым. То есть
данные в тег могут поступать из внешнего источника, редактироваться
пользователем, а также, в определённых случаях, рассчитываться.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

Новое значение тега может инициировать расчёт значений других тегов. В таком
случае в иерархии указывается, расчёт каких тегов инициируется изменением
значения данного тега.

Тревоги
"""""""
.. note::
   Сущность ``alerts``, класс в иерархии ``prsAlert``

Тревога - событие, возникающее при определённых условиях. Тревоги применяются,
в основном, для сигнализации о каких-то событиях (не обязательно критичных и
плохих, как может показаться из названия сущности, просто так сложилось
в АСУТП).

События возникновения тревог, также как и события изменения тегов и
события расписаний, могут запускать выполнение определённых процессов.

Экземпляр сущности ``alerts`` обязательно привязан к какому-либо тегу.
Каждое изменение значения тега, к которому привязаны тревоги, будет приводить к
пересчету условий возникновения тревог. Если условие выполняется, то произойдёт
событие возникновения тревоги.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:**

Объект "Паропровод". У него есть тег - "Температура пара". К тегу привязана
тревога "Превышение температуры". В условиях тревоги указано, что она должна
возникать при превышении значения температуры в 120 |deg| C.

Таким образом, каждое изменение тега будет приводить к проверке условия, что
новое значение тега превышает значение в 120 |deg| C. Если условие выполняется,
то произойдёт событие возникновения тревоги.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

Обычно в АСУТП тревоги бывают четырёх типов: LOLO-LO-HI-HIHI.

То есть:

* ``LOLO`` - нижний критичный уровень;
* ``LO`` - нижний предупредительный уровень;
* ``HI`` - верхний предупредительный уровень;
* ``HIHI`` - верхний критичный уровень.

В отличие от принятой практики, МПК Пересвет допускает создание любого
количества тревог, привязанных к тегу.

Кроме того, существуют дополнительные возможности при создании тревог:

* отложенные тревога;
  тревога, которая возникает спустя некоторое время после изменения значения
  тега на критичное

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:**
Тревога должна возникать, если температура пара в паропроводе превышает
120 |deg| C на протяжении не менее двух минут. Иначе ситуация считается
нормальной.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

* сложные тревоги;
  это такие тревоги, которые имеют сложные условия возникновения; к таким
  тревогам привязывается вычислительный метод, который определяет, должна ли
  возникать тревога; такие тревоги позволяют учитывать значения нескольких
  тегов, а также вообще любые дополнительные условия.

Тревоги могут быть квитируемые и не квитируемые.

Квитируемые тревоги - это такие тревоги, которые не исчезают до тех пор, пока
пользователь не отметит, что он их заметил (квитировал)

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:**
Тревога "Превышение температуры" у паропровода должна быть обязательно замечена
оператором, потому как возникновение такой тревоги влечёт за собой
необходимость проведения определённых работ по обслуживанию паропровода.

Поэтому даже после снижения температуры ниже 120 |deg| C тревога не пропадёт,
пока оператор не отметит, что заметил эту тревогу.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

Методы
""""""
.. note::
   Сущность ``methods``, класс в иерархии ``prsMethod``

Методы применяются:

* для вычисления значений тегов;
* для вычисления условий возникновения аварий;
* привязываются к событиям расписания, инициируя, таким образом, выполнение
  определённых вычислений/действий по расписанию;
* для запуска каких-либо процессов (рассылка почты, диспетчерские процессы
  при возникновении определённых событий и т.д.)

Хранилища данных
""""""""""""""""
.. note::
   Сущность ``dataStorages``, класс в иерархии ``prsDataStorage``

Сущность относится не к модели технического объекта, а к модели информационной
системы.

Хранилище данных - это база данных, в которой хранятся исторические значения
тегов и тревог.

В настоящий момент поддерживаются `PostgreSQL <https://www.postgresql.org/>`_
и `Victoriametrics <https://victoriametrics.com/>`_.

При написании соответствующего драйвера могут поддерживаться любые виды
хранилищ.

Платформа поддерживает возможность одновременной работы нескольких хранилищ,
причём разных типов.

Коннекторы
""""""""""
.. note::
   Сущность ``connectors``, класс в иерархии ``prsConnector``

Коннектор - специальная программа, являющаяся поставщиком данных от какого-либо
источника.

Обычно реализует собой возможность чтения данных по какому-либо протоколу
(modbus, OPC и т.д.).

Коннектор устанавливается как можно ближе к источнику данных,
инициирует связь с платформой по протоколу Websocket и передаёт в платформу
счианные из источника данных значения.

В свою очередь, принимает от платформы по этому же каналу сообщения об
измнениях параметров тегов и т.д.

Константы
"""""""""
.. note::
   Сущность ``constants``, класс в иерархии ``prsConstant``

Константы - определённые значения, используемые в рамках всей системы.
Передаются в вычислительные методы.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:** константа ``pieColors``: словарь, в котором указывается набор
цветов для отображения "пирогов" в отчётах.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

Расписания
""""""""""
.. note::
   Сущность ``schedules``, класс в иерархии ``prsSchedule``

Расписание определяет моменты возникновения событий, привязанных ко времени.
Эти события могут вызывать выполнение определённых методов:

* расчёт вычисляемых тегов;
* запуск выполнения внешних методов.

"Комплекты" сервисов
~~~~~~~~~~~~~~~~~~~~
Необязательно для каждой сущности должен существовать комплект из четырёх
микросервисов.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>

**Например:**

Константы - это сущность ``constants``. Имеет только два сервиса:
``constants_api_crud`` - API для создания-чтения-обновления-удаления констант и
``constants_model_crud`` - собственно, сам функционал для работы с иерархией.
Никакой собственной функциональности у констант нет. Они существуют только для
того, чтобы передаваться в методы. То есть, используются при работе сущности
``methods``.

Другой пример - сущность ``connectors``, коннекторы. Имеет три микросервиса:
``connectors_api_crud``, ``connectors_model_crud``, ``connectors_app``.
Микросервиса ``connectors_app_api`` нет, так как ``connectors_app``
не предоставляет никакой функциональности внешним клиентам. Задача
``connectors_app`` - поддержание связи по веб-сокету с коннекторами и приём
от них данных с дальнейшей отсылкой в платформу.

Ещё один пример - хранилища данных, сущность ``dataStorages``. Также не имеет
сервиса ``datastorages_app_api``, но имеет много разных сервисов
``datastorages_app``, каждый из которых реализует свой тип базы данных.

.. raw:: html

   <embed>
      <hr color="#000000" size="1">
   </embed>


Другие сервисы
~~~~~~~~~~~~~~
Платформа спроектирована таким образом, что допускает расширение списка
сущностей, которые могут присутствовать в статической модели и, соответственно,
внутри иерархии.

Для каждой новой сущности необходимо необходимо создать свой класс в схеме
LDAP-сервера и разработать комплект микросервисов, взяв за основу базовые
классы.

Экземпляры сущности в иерархии могут создаваться:

1. Внутри своего базового узла. Например:

   * основная иерархия - модель технического объекта, строится внутри
     узла ``objects``;
   * список хранилищ данных - внутри узла ``dataStorages``.

2. Внутри базовой иерархии - модели технического объекта. Например:

   * тревоги: тревоги могут создаваться только внутри узлов класса ``prsTag``,
     так как тревоги существуют только в привязке к тегам;
   * методы: могут быть привязаны к тегам или тревогам.

3. Внутри своего базового узла или внутри базовой иерархии. Примером здесь
   могут служить теги. Теги, чаще всего, создаются внутри основной иерархии,
   в качестве дочерних узлов для узлов класса ``prsObjects``.

   Но также возможны простые случаи применения платформы, для автоматизации
   совсем небольших объектов, где нет необходимости создавать иерархию
   объектов, то есть для автоматизации достаточно создать несколько тегов.

   В этом случае теги могут быть созданы линейным списком внутри узла ``tags``.

Хранилища данных
----------------
Значения тегов и тревог записываются в хранилища данных. В настоящий момент
поддерживаются два типа хранилищ: PostgreSQL и Victoriametrics.
Для поддержки нового типа хранилища необходимо написать соответствующий
микросервис.

.. figure:: pics/architecture_09.png
    :align: center

    Хранилища данных

Допускается одновременная работа нескольких хранилищ данных, как одного типа,
так и разных. Таким образом, можно хранить историю значений тегов и тревог
в разных хранилищах.

Брокер очередей сообщений
-------------------------
Таким образом, платформа представляет собой большое количество микросервисов.

Более того, одновременно может быть запущено несколько экземпляров каждого
микросервиса, причем на разных серверах. Этим реализуется масштабируемость
и высокая доступность (high availability) платформы.

Микросервисы работают не сами по себе, они взаимодействуют. Реализовывать
внутри каждого микросервиса связь со всеми необходимыми ему микросервисами -
непродуктивно.

Для реализации общения между микросервисами в архитектуру платформы добавлен
брокер очередей сообщений - `RabbitMQ <www.rabbitmq.com>`_.

.. figure:: pics/architecture_10.png
    :align: center

    Брокер сообщений

.. attention::
   Для понимания системы общения внутри платформы необходимо прочитать
   (не обязательно полное) руководство на RabbitMQ, с тем, чтобы хорошо
   разбираться в терминах:

   * обменник (exchange), а также в их типах (FANOUT, DIRECT);
   * очередь (queue);
   * привязка и ключ маршрутизации (binding, routing key).

Обменники сервисов
~~~~~~~~~~~~~~~~~~
Каждый микросервис, стартуя, декларирует несколько обменников.

Один - для публикации своих сообщений (в общем случае, может быть больше, чем
один) и несколько обменников, из которых ему нужны сообщения.

В документации на каждый сервис есть информация о том, какие сообщения
порождает сервис и на какие должен быть подписан.

Конфигурация обменников указывается в файле настроек сервиса, может быть
передана через переменные окружения, также значения по умолчанию
содержатся в модуле настроек сервиса.

В общем случае настройки обменников в файле конфигурации выглядят так:

.. code:: json

   {
      "publish": {
         "main": {
            "name": "<сущность>_pub",
            "type": "direct",
            "routing_key": "<service_name>_pub"
         }
      },
      "consume": {
         "main": {
            "name": "<ext_service_name>_pub",
            "type": "direct",
            "queue_name": "<service_name>_cons"
            "routing_key": "<ext_service_name>_pub"
      }
   }

.. note::
   Все сервисы, составшяющие ядро платформы, имеют настройки по умолчанию,
   позволяющие им работать вместе на одном сервере.

.. note::
   Предлагаемые здесь имена обменников, очередей носят рекомендательный
   характер. В каждом конкретном применении платформы имена могут другими.
   Но важно помнить, что предлагаемые правила именования позволяют
   упорядочить систему общения микросервисов.

Для примера рассмотрим найстройки сервисов сущности ``tags``.

tags_api_crud
"""""""""""""
Сервис принимает по REST API команды CRUD для тегов.

Принимая на вход команды, сервис проверяет корректность входных данных,
затем добавляет в командю ключ ``action`` и отправляет команду в обменник.

.. code:: json

   {
      "publish": {
         "main": {
            "name": "tags_pub",
            "type": "direct",
            "routing_key": "tags_api_crud_pub"
         }
      }
   }

.. note::
   Сервис может, по идее, принимать те же команды также через брокер сообщений,
   но отложим эту функциональность на будущее: в конфигурации нет
   обменников-потребителей.

tags_model_crud
"""""""""""""""
Сервис принимает сообщения, посылаемые сервисом ``tags_api_crud`` и отсылает
свои собственные сообщения после выполненных работ с иерархией (подробнее
см. `Логика сообщений при создании, обновлении и удалении узлов`_).

.. code:: json

   {
      "publish": {
         "main": {
            "name": "tags_pub",
            "type": "direct",
            "routing_key": "tags_model_crud_pub"
         }
      },
      "consume": {
         "main": {
            "name": "tags_pub",
            "type": "direct",
            "queue_name": "tags_model_crud_cons",
            "routing_key": "tags_api_crud_pub"
         }
      }
   }

Логика сообщений при создании, обновлении и удалении узлов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Рассмотрим следующую ситуацию.

Допустим, у нас есть иерархия и в этой иерархии - узел класса
``prsСущность_1``. Через некоторое время была создана группа сервисов
для работы с новой сущностью ``Сущность_2``, причём узлы-экземпляры этой
сущности являются дочерними по отношению к узлам сущности ``Сущность_1``:
